# Widget Architecture

## Overview

The ManagerOS dashboard uses a self-contained, module-based widget architecture. Each widget is a self-contained module that exports information about how to present itself, how to fetch related data, and how to render. Widgets are React Server Components that handle their own data fetching and rendering logic.

## Architecture Principles

1. **Self-Contained Modules**: Each widget is a complete module with its own data fetching, visibility logic, and rendering
2. **Server Components**: Widgets are React Server Components that fetch data on the server
3. **Registry Pattern**: Widgets are registered in a central registry for discovery and management
4. **Type Safety**: Strong TypeScript interfaces ensure consistency across widgets
5. **Separation of Concerns**: Widgets handle their own logic, dashboard orchestrates rendering

## Core Components

### Widget Interface

All widgets implement the `Widget` interface (`src/components/widgets/types.ts`):

```typescript
interface Widget {
  metadata: WidgetMetadata
  checkVisibility(context: WidgetContext): Promise<WidgetVisibility> | WidgetVisibility
  fetchData(context: WidgetContext): Promise<unknown>
  render(data: unknown, metadata: WidgetMetadata, context: WidgetContext): ReactNode
}
```

### Widget Metadata

Each widget exports metadata describing how it should be presented:

```typescript
interface WidgetMetadata {
  id: string                    // Unique identifier
  title: string                 // Display title
  icon?: LucideIcon            // Optional icon component (rendered as JSX in render method)
  minWidth?: string            // Minimum width
  defaultVisible: boolean      // Default visibility
  category?: string            // Widget category
  description?: string           // Widget description
}
```

**Important**: Icons are stored as component references in metadata but must be rendered as JSX in the `render()` method before passing to client components.

### Widget Context

Context provides widgets with user and organization information:

```typescript
interface WidgetContext {
  userId: string
  organizationId: string
  personId?: string | null
  hasLinkedPerson: boolean
}
```

### Widget Registry

The widget registry (`src/components/widgets/registry.ts`) manages all available widgets:

- **Registration**: Widgets register themselves on module load
- **Discovery**: Dashboard queries registry for available widgets
- **Filtering**: Can filter widgets by category or other criteria

## Widget Lifecycle

1. **Registration**: Widget registers itself in the registry (on module import)
2. **Visibility Check**: Dashboard calls `checkVisibility()` to determine if widget should be shown
3. **Data Fetching**: If visible, dashboard calls `fetchData()` to get widget data
4. **Rendering**: Dashboard calls `render()` to get React Server Component
5. **Client Wrapping**: Client component wraps widgets that need interactivity

## Widget Types

### Stats Card Widgets

**Location**: `src/components/widgets/*-widget.tsx`

**Examples**:
- `total-people-widget.tsx` - Total people count
- `direct-reports-widget.tsx` - Direct reports count
- `one-on-ones-needed-widget.tsx` - Reports needing 1:1s
- `feedback-360-needed-widget.tsx` - Reports needing 360 feedback
- `max-reports-exceeded-widget.tsx` - Managers exceeding max reports

**Pattern**:
```typescript
export const totalPeopleWidget: Widget = {
  metadata: {
    id: 'total-people',
    title: 'Total People',
    icon: Users,  // Component reference stored here
    minWidth: '160px',
    defaultVisible: true,
    category: 'stats',
  },
  
  async checkVisibility(context) {
    return { visible: true }
  },
  
  async fetchData(context) {
    const count = await prisma.person.count({...})
    return { count }
  },
  
  render(data, metadata, context) {
    const { count } = data as { count: number }
    const IconComponent = metadata.icon
    
    // Render icon as JSX (required for server-to-client component boundary)
    return (
      <WidgetCard
        title={metadata.title}
        titleIcon={IconComponent ? <IconComponent className='w-3 h-3 text-muted-foreground' /> : undefined}
        minWidth={metadata.minWidth}
        // Note: No onClick prop - interactivity handled by client wrapper
      >
        <div>{count}</div>
      </WidgetCard>
    )
  },
}
```

**Key Points**:
- Icons must be rendered as JSX elements, not passed as component references
- No `onClick` props - interactivity is handled by `PeopleDashboardWidgetsClient` wrapper
- Widgets are server components that render server-safe JSX

### Chart Widgets

**Location**: `src/components/widgets/*-widget.tsx`

**Examples**:
- `team-breakdown-widget.tsx` - Team distribution bar chart
- `job-role-breakdown-widget.tsx` - Job role distribution pie chart

**Pattern**: Similar to stats widgets but use separate client components for Recharts:

```typescript
// Widget file (server component)
import { TeamBreakdownChart } from './team-breakdown-chart'  // Client component

render(data, metadata, context) {
  const { data: chartData } = data as TeamBreakdownData
  return (
    <WidgetCard title={metadata.title}>
      <TeamBreakdownChart data={chartData} />  {/* Client component */}
    </WidgetCard>
  )
}
```

**Client Chart Components**:
- `team-breakdown-chart.tsx` - Client component for bar chart (uses Recharts)
- `job-role-breakdown-chart.tsx` - Client component for pie chart (uses Recharts)

These are separate `'use client'` components because Recharts requires browser APIs.

## Dashboard Integration

### People Dashboard Server

**Location**: `src/components/people/people-dashboard-server.tsx`

**Responsibilities**:
- Creates widget context from user data
- Queries widget registry for all widgets
- Checks visibility for each widget
- Fetches data for visible widgets
- Renders widgets grouped by category
- Passes rendered widgets to client component for interactivity

### People Dashboard Widgets Client

**Location**: `src/components/people/people-dashboard-widgets.tsx`

**Responsibilities**:
- Wraps widgets in click handlers for interactivity
- Manages modals for widget actions
- Handles navigation for clickable widgets
- Applies hover effects to clickable widgets

**Pattern**:
```typescript
// Wraps clickable widgets in div with onClick
<div
  onClick={() => handleWidgetClick(widgetId)}
  className='cursor-pointer [&>div]:hover:bg-accent/50 [&>div]:transition-colors'
>
  {widgetElement}  {/* Server-rendered widget */}
</div>
```

**Important**: Widgets should NOT have `onClick` props. All interactivity is handled by this client wrapper component.

## Creating a New Widget

1. **Create Widget Module**: Create a new file in `src/components/widgets/`
2. **Implement Widget Interface**: Export a widget object implementing the `Widget` interface
3. **Register Widget**: Import and register in `src/components/widgets/index.ts`
4. **Test Visibility**: Ensure `checkVisibility()` works correctly
5. **Test Data Fetching**: Ensure `fetchData()` returns correct data
6. **Test Rendering**: Ensure `render()` produces correct UI

**Example**:
```typescript
// src/components/widgets/my-widget.tsx
import { Users } from 'lucide-react'
import { prisma } from '@/lib/db'
import { WidgetCard } from '@/components/widgets'
import type { Widget, WidgetContext, WidgetVisibility } from '@/components/widgets'

export const myWidget: Widget = {
  metadata: {
    id: 'my-widget',
    title: 'My Widget',
    icon: Users,  // Store component reference
    defaultVisible: true,
    category: 'stats',
  },
  
  async checkVisibility(context) {
    return { visible: true }
  },
  
  async fetchData(context) {
    // Fetch your data
    const value = await prisma.person.count({...})
    return { value }
  },
  
  render(data, metadata, _context) {
    const { value } = data as { value: number }
    const IconComponent = metadata.icon
    
    // Render icon as JSX (required for server-to-client boundary)
    return (
      <WidgetCard
        title={metadata.title}
        titleIcon={IconComponent ? <IconComponent className='w-3 h-3 text-muted-foreground' /> : undefined}
        minWidth={metadata.minWidth}
        // No onClick - handled by client wrapper
      >
        <div>{value}</div>
      </WidgetCard>
    )
  },
}
```

## Best Practices

1. **Self-Contained Logic**: Each widget should handle its own data fetching and visibility logic
2. **Server Components**: Keep widgets as Server Components - use client components only for interactivity or browser APIs (like Recharts)
3. **Icon Handling**: Always render icons as JSX elements in `render()` method, never pass component references to client components
4. **No Event Handlers**: Never pass `onClick` or other event handlers from server components - use client wrapper component instead
5. **Type Safety**: Use TypeScript interfaces for widget data structures
6. **Error Handling**: Handle errors gracefully in `fetchData()` and `checkVisibility()`
7. **Performance**: Use `checkVisibility()` to avoid unnecessary data fetching
8. **Reusability**: Design widgets to be reusable across different contexts
9. **Documentation**: Document widget purpose, data requirements, and visibility conditions
10. **Client Components**: Create separate client components for charts or interactive elements that require browser APIs

## Current Widgets

### Stats Widgets
- `total-people` - Total people in organization
- `direct-reports` - Direct reports count (requires linked person)
- `reports-without-recent-one-on-one` - Reports needing 1:1s (requires direct reports)
- `reports-without-recent-feedback-360` - Reports needing 360 feedback (requires direct reports)
- `managers-exceeding-max-reports` - Managers exceeding max reports (requires rule)

### Chart Widgets
- `team-chart` - Team breakdown bar chart
- `job-role-chart` - Job role breakdown pie chart

## Future Enhancements

1. **User Preferences**: Store widget visibility/order in `UserSettings`
2. **Widget Reordering**: Drag-and-drop or settings-based reordering
3. **Widget Sizing**: Allow users to control widget sizes
4. **More Widget Types**: Expand beyond stats and charts
5. **Widget Settings**: Per-widget configuration options
6. **Widget Dependencies**: Support for widgets that depend on other widgets' data

## Related Files

- `src/components/widgets/types.ts` - Widget type definitions
- `src/components/widgets/registry.ts` - Widget registry
- `src/components/widgets/index.ts` - Widget registration
- `src/components/people/people-dashboard-server.tsx` - Dashboard server component
- `src/components/people/people-dashboard-widgets.tsx` - Dashboard client wrapper
- `src/components/widgets/team-breakdown-chart.tsx` - Client component for bar chart
- `src/components/widgets/job-role-breakdown-chart.tsx` - Client component for pie chart
- `src/components/widgets/widget-card.tsx` - Base widget card component
