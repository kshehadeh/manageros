#!/usr/bin/env bun

/**
 * Generate Help Content
 *
 * This script reads markdown files from the help directory and generates
 * a TypeScript file with the content embedded. This approach works with
 * both webpack and Turbopack.
 *
 * The script parses front matter from markdown files to extract metadata.
 */

import { readFileSync, readdirSync, writeFileSync, mkdirSync } from 'fs'
import { join } from 'path'

const helpDir = join(process.cwd(), 'help')
const outputDir = join(process.cwd(), 'src/lib/help')
const indexFile = join(outputDir, 'index.ts')

interface FrontMatter {
  id: string
  title: string
  category: string
}

/**
 * Parse front matter from markdown content
 */
function parseFrontMatter(content: string): {
  frontMatter: FrontMatter | null
  markdown: string
} {
  const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/
  const match = content.match(frontMatterRegex)

  if (!match) {
    return { frontMatter: null, markdown: content }
  }

  const [, frontMatterContent, markdownContent] = match

  // Parse YAML-like front matter
  const frontMatter: Partial<FrontMatter> = {}
  const lines = frontMatterContent.split('\n')

  for (const line of lines) {
    const trimmedLine = line.trim()
    if (trimmedLine && !trimmedLine.startsWith('#')) {
      const colonIndex = trimmedLine.indexOf(':')
      if (colonIndex > 0) {
        const key = trimmedLine.substring(0, colonIndex).trim()
        const value = trimmedLine.substring(colonIndex + 1).trim()
        frontMatter[key as keyof FrontMatter] = value
      }
    }
  }

  // Validate required fields
  if (!frontMatter.id || !frontMatter.title || !frontMatter.category) {
    console.warn('‚ö†Ô∏è  Missing required front matter fields:', frontMatter)
    return { frontMatter: null, markdown: content }
  }

  return {
    frontMatter: frontMatter as FrontMatter,
    markdown: markdownContent,
  }
}

function generateHelpContent() {
  console.log('üîÑ Generating help content from markdown files...')

  try {
    // Ensure output directory exists
    try {
      readdirSync(outputDir)
    } catch {
      // Directory doesn't exist, create it
      mkdirSync(outputDir, { recursive: true })
    }

    // Read all markdown files
    const files = readdirSync(helpDir).filter(
      file => file.endsWith('.md') && file !== 'README.md'
    )
    const helpIds: string[] = []
    const categories = new Set<string>()

    for (const file of files) {
      try {
        // Read the markdown file
        const filePath = join(helpDir, file)
        const fileContent = readFileSync(filePath, 'utf-8')

        // Parse front matter
        const { frontMatter, markdown } = parseFrontMatter(fileContent)

        if (!frontMatter) {
          console.warn(`‚ö†Ô∏è  No valid front matter found in: ${file}`)
          continue
        }

        // Escape the markdown content for TypeScript string literal
        const escapedContent = markdown
          .replace(/\\/g, '\\\\')
          .replace(/`/g, '\\`')
          .replace(/\${/g, '\\${')

        // Generate individual TypeScript file for this help topic
        const tsContent = `/**
 * Auto-generated help content: ${frontMatter.title}
 * 
 * This file is automatically generated from ${file}.
 * Do not edit this file manually. Instead, edit the markdown file and run:
 * 
 *   bun run help:generate
 * 
 * Generated on: ${new Date().toISOString()}
 */

export interface HelpContent {
  id: string
  title: string
  content: string
  category?: string
}

export const helpContent: HelpContent = {
  id: '${frontMatter.id}',
  title: '${frontMatter.title}',
  category: '${frontMatter.category}',
  content: \`${escapedContent}\`,
}
`

        // Write individual file
        const outputFile = join(outputDir, `${frontMatter.id}.ts`)
        writeFileSync(outputFile, tsContent)

        helpIds.push(frontMatter.id)
        categories.add(frontMatter.category)

        console.log(`‚úÖ Generated: ${frontMatter.title} (${frontMatter.id})`)
      } catch (error) {
        console.error(`‚ùå Error reading help file ${file}:`, error)
      }
    }

    // Generate index file that imports all help content
    const indexContent = `/**
 * Auto-generated help content index
 * 
 * This file is automatically generated from markdown files in the help/ directory.
 * Do not edit this file manually. Instead, edit the markdown files and run:
 * 
 *   bun run help:generate
 * 
 * Generated on: ${new Date().toISOString()}
 */

export interface HelpContent {
  id: string
  title: string
  content: string
  category?: string
}

// Import all help content files
${helpIds
  .map(id => {
    const camelCaseId = id.replace(/-([a-z])/g, (_, letter) =>
      letter.toUpperCase()
    )
    return `import { helpContent as ${camelCaseId} } from './${id}'`
  })
  .join('\n')}

// Combine all help content into a single object
export const helpContent: Record<string, HelpContent> = {
${helpIds
  .map(id => {
    const camelCaseId = id.replace(/-([a-z])/g, (_, letter) =>
      letter.toUpperCase()
    )
    return `  '${id}': ${camelCaseId}`
  })
  .join(',\n')}
}

/**
 * Get help content by ID
 */
export function getHelpContent(id: string): HelpContent | undefined {
  return helpContent[id]
}

/**
 * Get all help content for a specific category
 */
export function getHelpContentByCategory(category: string): HelpContent[] {
  return Object.values(helpContent).filter(item => item.category === category)
}

/**
 * Get all available help content
 */
export function getAllHelpContent(): HelpContent[] {
  return Object.values(helpContent)
}

/**
 * Get all available categories
 */
export function getHelpCategories(): string[] {
  return Array.from(new Set(${JSON.stringify(Array.from(categories))})).sort()
}

/**
 * Check if a help ID exists
 */
export function hasHelpContent(id: string): boolean {
  return id in helpContent
}

/**
 * Get all available help IDs
 */
export function getHelpIds(): string[] {
  return ${JSON.stringify(helpIds)}
}
`

    // Write the index file
    writeFileSync(indexFile, indexContent)

    console.log(`‚úÖ Generated help index: ${indexFile}`)
    console.log(`üìä ${helpIds.length} help topics processed`)
    console.log(`üìÅ Generated ${helpIds.length + 1} TypeScript files`)

    return helpIds.length
  } catch (error) {
    console.error('‚ùå Error generating help content:', error)
    process.exit(1)
  }
}

// Run if called directly
if (import.meta.main) {
  generateHelpContent()
}

export { generateHelpContent }
