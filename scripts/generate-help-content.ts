#!/usr/bin/env bun

/**
 * Generate Help Content
 *
 * This script reads markdown files from the help directory and generates
 * a TypeScript file with the content embedded. This approach works with
 * both webpack and Turbopack.
 *
 * The script parses front matter from markdown files to extract metadata.
 */

import {
  readFileSync,
  readdirSync,
  writeFileSync,
  mkdirSync,
  statSync,
} from 'fs'
import { join } from 'path'

const helpDir = join(process.cwd(), 'help')
const outputDir = join(process.cwd(), 'src/lib/help')
const indexFile = join(outputDir, 'index.ts')

interface FrontMatter {
  id: string
  title: string
  category: string
}

/**
 * Parse front matter from markdown content
 */
function parseFrontMatter(content: string): {
  frontMatter: FrontMatter | null
  markdown: string
} {
  const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/
  const match = content.match(frontMatterRegex)

  if (!match) {
    return { frontMatter: null, markdown: content }
  }

  const [, frontMatterContent, markdownContent] = match

  // Parse YAML-like front matter
  const frontMatter: Partial<FrontMatter> = {}
  const lines = frontMatterContent.split('\n')

  for (const line of lines) {
    const trimmedLine = line.trim()
    if (trimmedLine && !trimmedLine.startsWith('#')) {
      const colonIndex = trimmedLine.indexOf(':')
      if (colonIndex > 0) {
        const key = trimmedLine.substring(0, colonIndex).trim()
        const value = trimmedLine.substring(colonIndex + 1).trim()
        frontMatter[key as keyof FrontMatter] = value
      }
    }
  }

  // Validate required fields
  if (!frontMatter.id || !frontMatter.title || !frontMatter.category) {
    console.warn('‚ö†Ô∏è  Missing required front matter fields:', frontMatter)
    return { frontMatter: null, markdown: content }
  }

  return {
    frontMatter: frontMatter as FrontMatter,
    markdown: markdownContent,
  }
}

/**
 * Recursively find all markdown files in a directory
 */
function findMarkdownFiles(
  dir: string,
  relativePath = ''
): Array<{ filePath: string; relativePath: string }> {
  const files: Array<{ filePath: string; relativePath: string }> = []

  try {
    const items = readdirSync(dir)

    for (const item of items) {
      const itemPath = join(dir, item)
      const itemRelativePath = relativePath ? join(relativePath, item) : item
      const stat = statSync(itemPath)

      if (stat.isDirectory()) {
        // Recursively search subdirectories
        files.push(...findMarkdownFiles(itemPath, itemRelativePath))
      } else if (item.endsWith('.md') && item !== 'README.md') {
        files.push({ filePath: itemPath, relativePath: itemRelativePath })
      }
    }
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Could not read directory ${dir}:`, error)
  }

  return files
}

/**
 * Derive category from folder structure
 */
function deriveCategoryFromPath(relativePath: string): string {
  const folderName = relativePath.split('/')[0]

  // Map folder names to display categories
  const categoryMap: Record<string, string> = {
    'tasks-projects': 'Tasks & Projects',
    'people-teams': 'People & Teams',
    'meetings-communication': 'Meetings & Communication',
    integrations: 'Integrations',
    'feedback-development': 'Feedback & Development',
  }

  return categoryMap[folderName] || 'Uncategorized'
}

function generateHelpContent() {
  console.log('üîÑ Generating help content from hierarchical markdown files...')

  try {
    // Ensure output directory exists
    try {
      readdirSync(outputDir)
    } catch {
      // Directory doesn't exist, create it
      mkdirSync(outputDir, { recursive: true })
    }

    // Find all markdown files recursively
    const markdownFiles = findMarkdownFiles(helpDir)
    const helpIds: string[] = []
    const categories = new Set<string>()

    for (const { filePath, relativePath } of markdownFiles) {
      try {
        // Read the markdown file
        const fileContent = readFileSync(filePath, 'utf-8')

        // Parse front matter
        const { frontMatter, markdown } = parseFrontMatter(fileContent)

        if (!frontMatter) {
          console.warn(`‚ö†Ô∏è  No valid front matter found in: ${relativePath}`)
          continue
        }

        // Use category from front matter, or derive from folder structure
        const category =
          frontMatter.category || deriveCategoryFromPath(relativePath)

        // Escape the markdown content for TypeScript string literal
        const escapedContent = markdown
          .replace(/\\/g, '\\\\')
          .replace(/`/g, '\\`')
          .replace(/\${/g, '\\${')

        // Generate individual TypeScript file for this help topic
        const tsContent = `/**
 * Auto-generated help content: ${frontMatter.title}
 * 
 * This file is automatically generated from ${relativePath}.
 * Do not edit this file manually. Instead, edit the markdown file and run:
 * 
 *   bun run help:generate
 * 
 * Generated on: ${new Date().toISOString()}
 */

export interface HelpContent {
  id: string
  title: string
  content: string
  category?: string
}

export const helpContent: HelpContent = {
  id: '${frontMatter.id}',
  title: '${frontMatter.title}',
  category: '${category}',
  content: \`${escapedContent}\`,
}
`

        // Write individual file only if content has changed
        const outputFile = join(outputDir, `${frontMatter.id}.ts`)
        try {
          const existingContent = readFileSync(outputFile, 'utf-8')
          // Extract the content part from existing file to compare
          const existingContentMatch = existingContent.match(
            /content: `([\s\S]*?)`,?\s*}/
          )
          const existingEscapedContent = existingContentMatch
            ? existingContentMatch[1]
            : ''

          // Only write if content has actually changed
          if (existingEscapedContent !== escapedContent) {
            writeFileSync(outputFile, tsContent)
            console.log(
              `‚úÖ Updated: ${frontMatter.title} (${frontMatter.id}) from ${relativePath}`
            )
          } else {
            console.log(
              `‚è≠Ô∏è  Skipped: ${frontMatter.title} (${frontMatter.id}) - no changes`
            )
          }
        } catch {
          // File doesn't exist, write it
          writeFileSync(outputFile, tsContent)
          console.log(
            `‚úÖ Generated: ${frontMatter.title} (${frontMatter.id}) from ${relativePath}`
          )
        }

        helpIds.push(frontMatter.id)
        categories.add(category)

        console.log(
          `‚úÖ Generated: ${frontMatter.title} (${frontMatter.id}) from ${relativePath}`
        )
      } catch (error) {
        console.error(`‚ùå Error reading help file ${relativePath}:`, error)
      }
    }

    // Generate index file that imports all help content
    const indexContent = `/**
 * Auto-generated help content index
 * 
 * This file is automatically generated from markdown files in the help/ directory.
 * Do not edit this file manually. Instead, edit the markdown files and run:
 * 
 *   bun run help:generate
 * 
 * Generated on: ${new Date().toISOString()}
 */

export interface HelpContent {
  id: string
  title: string
  content: string
  category?: string
}

// Import all help content files
${helpIds
  .map(id => {
    const camelCaseId = id.replace(/-([a-z])/g, (_, letter) =>
      letter.toUpperCase()
    )
    return `import { helpContent as ${camelCaseId} } from './${id}'`
  })
  .join('\n')}

// Combine all help content into a single object
export const helpContent: Record<string, HelpContent> = {
${helpIds
  .map(id => {
    const camelCaseId = id.replace(/-([a-z])/g, (_, letter) =>
      letter.toUpperCase()
    )
    return `  '${id}': ${camelCaseId}`
  })
  .join(',\n')}
}

/**
 * Get help content by ID
 */
export function getHelpContent(id: string): HelpContent | undefined {
  return helpContent[id]
}

/**
 * Get all help content for a specific category
 */
export function getHelpContentByCategory(category: string): HelpContent[] {
  return Object.values(helpContent).filter(item => item.category === category)
}

/**
 * Get all available help content
 */
export function getAllHelpContent(): HelpContent[] {
  return Object.values(helpContent)
}

/**
 * Get all available categories
 */
export function getHelpCategories(): string[] {
  return Array.from(new Set(${JSON.stringify(Array.from(categories))})).sort()
}

/**
 * Check if a help ID exists
 */
export function hasHelpContent(id: string): boolean {
  return id in helpContent
}

/**
 * Get all available help IDs
 */
export function getHelpIds(): string[] {
  return ${JSON.stringify(helpIds)}
}
`

    // Write the index file only if content has changed
    try {
      const existingIndexContent = readFileSync(indexFile, 'utf-8')
      // Extract the helpIds array from existing file to compare
      const existingIdsMatch = existingIndexContent.match(/return \[(.*?)\]/s)
      const existingIds = existingIdsMatch
        ? existingIdsMatch[1]
            .split(',')
            .map(id => id.trim().replace(/['"]/g, ''))
        : []

      // Compare sorted arrays
      const sortedExistingIds = [...existingIds].sort()
      const sortedNewIds = [...helpIds].sort()

      // Only write if the help IDs have changed
      if (JSON.stringify(sortedExistingIds) !== JSON.stringify(sortedNewIds)) {
        writeFileSync(indexFile, indexContent)
        console.log(`‚úÖ Updated help index: ${indexFile}`)
      } else {
        console.log(`‚è≠Ô∏è  Skipped help index - no changes`)
      }
    } catch {
      // File doesn't exist, write it
      writeFileSync(indexFile, indexContent)
      console.log(`‚úÖ Generated help index: ${indexFile}`)
    }

    console.log(`üìä ${helpIds.length} help topics processed`)

    return helpIds.length
  } catch (error) {
    console.error('‚ùå Error generating help content:', error)
    process.exit(1)
  }
}

// Run if called directly
if (import.meta.main) {
  generateHelpContent()
}

export { generateHelpContent }
