---
description: User Interface related rules when the UI is being updated
alwaysApply: false
---
# User Interface Rules

Entities like meetings, initiatives, people, etc. should follow these rules:

* The layout of the page should use available horizontal space
* When creating a series of action buttons for the entity detail page, prefer use an action drop down with an ellipsis button instead of separate buttons.
* Avoid using cards to surround groups of information.  Instead, use the `PageSection` component with a `SectionHeader` and appropriate spacing.
* Always use the `PageSection` component for all page sections to ensure consistent styling across the application. The component accepts:
  * `header` prop (optional): Use `SectionHeader` component for section titles
  * `children`: The main content of the section
  * `className` (optional): Additional CSS classes if needed
* Use breadcrumbs to navigate between pages. All pages must explicitly set breadcrumbs using the `PageBreadcrumbSetter` component. See docs/breadcrumbs.md for details.
* When displaying a list of entities, use the shadcn table component instead of a list of cards.  Limit the columns to those that are necessary and relevant to the entity.
* When creating a new table list, add support for filtering using the same UI as the persons table.  Use the search bar and the filter button to filter the table. The filter button will popup a modal with the filters.
* We do not need to include a "Back to..." button since we have the breadcrumbs to navigate back to the previous page.
* Use consistent iconography for all entities.  Use the Lucide icons for all icons. Determine the right icon based on the icon used in the sidebar

## Skeleton Rules

* Use the Skeleton component for all loading states.
* Whenever the layout of a page changes that has an associated loading state (either through loading.tsx or a loading skeleton), use the Skeleton component to display the loading state and make it match the layout of the page.  Try to reuse the same skeleton components whenever possible. Try to use the same components as the actual page whenever possible.  Match any static text whenever possible.

## Theming Rules

* Use the theme tokens for all colors.
* Read the docs/theming.md file for more information.

## Shadcn Rules

* Use the shadcn components for all UI.
* Read the components.json file for more information.

## Tailwind Rules

* Use the tailwind utility classes for all UI.
* Read the tailwind.config.ts file for more information.

## Forms

When creating forms, use the shadcn form components.
Only use cards when there is more than one section.  Each section can be in a card, but do not use a card if there's only a single section.

## Components

* Reuse components whenever possible.
* Look for other places where similar component are used and modify them to fit the new use case and reuse.  But weigh that against the complexity being introduced to satisfy this constraint.  If the complexity is too high, then create a new component.

## Shared Layout Components

All entity detail pages and list pages must use the shared layout components instead of CSS classes directly. This ensures consistency and enables centralized layout management.

### PageContainer

* **Always use `PageContainer` component** instead of `page-container` CSS class
* Import from `@/components/ui/page-container`
* Wraps entire page with consistent spacing
* Example:

  ```tsx
  import { PageContainer } from '@/components/ui/page-container'
  
  <PageContainer>
    {/* Page content */}
  </PageContainer>
  ```

### PageHeader

* **Always use `PageHeader` component** instead of `page-header` CSS class
* Import from `@/components/ui/page-header`
* Supports simple headers with props or complex headers with children
* Example - Simple:

  ```tsx
  import { PageHeader } from '@/components/ui/page-header'
  import { Rocket } from 'lucide-react'
  
  <PageHeader
    title='Initiatives'
    titleIcon={Rocket}
    subtitle='Manage initiatives'
    actions={<Button>Create</Button>}
  />
  ```

* Example - Complex (with children):

  ```tsx
  <PageHeader>
    <div className='flex items-start justify-between'>
      <div className='flex-1'>
        <h1 className='page-title'>{title}</h1>
        {/* Custom content */}
      </div>
      <ActionsDropdown />
    </div>
  </PageHeader>
  ```

### PageContent, PageMain, PageSidebar

* **Always use these components** for two-column layouts instead of CSS classes
* Import from `@/components/ui/page-content`, `@/components/ui/page-main`, `@/components/ui/page-sidebar`
* `PageContent` handles the flex layout
* `PageMain` wraps main content column
* `PageSidebar` wraps sidebar column
* Example:

  ```tsx
  import { PageContent } from '@/components/ui/page-content'
  import { PageMain } from '@/components/ui/page-main'
  import { PageSidebar } from '@/components/ui/page-sidebar'
  
  <PageContent>
    <PageMain>
      {/* Main content */}
    </PageMain>
    <PageSidebar>
      {/* Sidebar content */}
    </PageSidebar>
  </PageContent>
  ```

### Complete Page Structure

All entity detail pages should follow this structure:

```tsx
<PageContainer>
  <PageHeader title={...} actions={...} />
  <PageContent>
    <PageMain>
      <PageSection>
        {/* Content */}
      </PageSection>
    </PageMain>
    <PageSidebar>
      <PageSection>
        {/* Sidebar content */}
      </PageSection>
    </PageSidebar>
  </PageContent>
</PageContainer>
```

For list pages (no sidebar):

```tsx
<PageContainer>
  <PageHeader title={...} actions={...} />
  <PageContent>
    <PageSection>
      {/* List/table content */}
    </PageSection>
  </PageContent>
</PageContainer>
```

## PageSection Component

* **Always use `PageSection` component** instead of manually applying `page-section` class
* Import from `@/components/ui/page-section`
* Use `SectionHeader` component for section titles via the `header` prop
* Example:

  ```tsx
  import { PageSection } from '@/components/ui/page-section'
  import { SectionHeader } from '@/components/ui/section-header'
  
  <PageSection
    header={<SectionHeader icon={FileText} title='Section Title' />}
  >
    {/* Section content */}
  </PageSection>
  ```

* For sections without headers, simply wrap content:

  ```tsx
  <PageSection>
    {/* Content */}
  </PageSection>
  ```
